include_controls 'oracle-database-12c-stig-baseline' do
    control 'V-61579' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61671' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61867' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
          skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61441' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
         skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61447' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61489' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61511' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61515' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61531' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61533' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61535' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61601' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61965' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61685' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61703' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61705' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61707' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61709' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61713' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61715' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61733' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61737' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61543' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61741' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61743' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61747' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61749' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61783' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61815' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61545' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61759' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61787' do
      impact 0.0
      describe 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on' do
        skip 'This control is not applicable on oracle within aws rds, as aws manages the operating system in which the oracle database is running on'
      end
    end

    control 'V-61603' do
      title "The DBMS must verify account lockouts persist until reset by an
      administrator."
      desc "Anytime an authentication method is exposed, to allow for the
      utilization of an application, there is a risk that attempts will be made to
      obtain unauthorized access.
    
          To defeat these attempts, organizations define the number of times a user
      account may consecutively fail a logon attempt. The organization also defines
      the period of time in which these consecutive failed attempts may occur.
    
          By limiting the number of failed logon attempts, the risk of unauthorized
      system access via user password guessing, otherwise known as brute forcing, is
      reduced. Limits are imposed by locking the account.
    
          Note that user authentication and account management must be done via an
      enterprise-wide mechanism whenever possible.  Examples of enterprise-level
      authentication/access mechanisms include, but are not limited to, Active
      Directory and LDAP. This requirement applies to cases where it is necessary to
      have accounts directly managed by Oracle.
      "
      impact 0.5
      tag "gtitle": 'SRG-APP-000065-DB-000024'
      tag "gid": 'V-61603'
      tag "rid": 'SV-76093r2_rule'
      tag "stig_id": 'O121-C2-004900'
      tag "fix_id": 'F-67519r1_fix'
      tag "cci": ['CCI-002236']
      tag "nist": ['AC-7 b', 'Rev_4']
      tag "false_negatives": nil
      tag "false_positives": nil
      tag "documentable": false
      tag "mitigations": nil
      tag "severity_override_guidance": false
      tag "potential_impacts": nil
      tag "third_party_tools": nil
      tag "mitigation_controls": nil
      tag "responsibility": nil
      tag "ia_controls": nil
      tag "check": "The account lockout duration is defined in the profile assigned
      to a user.
    
      To see what profile is assigned to a user, enter the query:
    
      SQL>SELECT profile FROM dba_users WHERE username = '<username>'
    
      This will return the profile name assigned to that user.
    
      The user profile, ORA_STIG_PROFILE, has been provided (starting with Oracle
      12.1.0.2) to satisfy the STIG requirements pertaining to the profile
      parameters. Oracle recommends that this profile be customized with any
      site-specific requirements and assigned to all users where applicable.  Note:
      It remains necessary to create a customized replacement for the password
      validation function, ORA12C_STRONG_VERIFY_FUNCTION, if relying on this
      technique to verify password complexity.
    
      Now check the values assigned to the profile returned from the query above:
    
      column profile format a20
      column limit format a20
      SQL>SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
      'ORA_STIG_PROFILE';
    
      Check the settings for password_lock_time - this specifies how long to lock the
      account after the number of consecutive failed logon attempts reaches the
      limit. If the value is not UNLIMITED, this is a finding."
      tag "fix": "Configure the DBMS settings to specify indefinite lockout
      duration:
      ALTER PROFILE ORA_STIG_PROFILE LIMIT PASSWORD_LOCK_TIME UNLIMITED;"
    
      sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))
    
      query = %{
        SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
      '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_LOCK_TIME'
      }
    
      user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq
    
      user_profiles.each do |profile|
        next if profile == "RDSADMIN"
        password_lock_time = sql.query(format(query, profile: profile)).column('limit')
    
        describe "The oracle database account password lock time for profile: #{profile}" do
          subject { password_lock_time }
          it { should cmp 'UNLIMITED' }
        end
      end
      if user_profiles.empty?
        describe 'There are no user profiles, therefore this control is NA' do
          skip 'There are no user profiles, therefore this control is NA'
        end
      end
    end

    control 'V-61607' do
      sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))
    
      query = %{
        SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
      '%<profile>s' AND RESOURCE_NAME = 'FAILED_LOGIN_ATTEMPTS'
      }
    
      user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq
    
      user_profiles.each do |profile|
        next if profile == "RDSADMIN"
        password_lock_time = sql.query(format(query, profile: profile)).column('limit')
    
        describe "The oracle database limit for failed login attempts for profile: #{profile}" do
          subject { password_lock_time }
          it { should cmp <= input('failed_logon_attempts') }
        end
      end
      if user_profiles.empty?
        describe 'There are no user profiles, therefore this control is NA' do
          skip 'There are no user profiles, therefore this control is NA'
        end
      end
    end

    control 'V-61617' do
  title "Databases utilizing Discretionary Access Control (DAC) must enforce a
  policy that limits propagation of access rights."
  desc "Discretionary Access Control (DAC) is based on the premise that
  individual users are owners of objects and therefore have discretion over
  who should be authorized to access the object and in which mode (e.g., read or
  write). Ownership is usually acquired as a consequence of creating the object
  or via specified ownership assignment.

      DAC allows the owner to determine who will have access to objects they
  control. An example of DAC includes user-controlled file permissions. DAC
  models have the potential for the access controls to propagate without limit,
  resulting in unauthorized access to said objects.

      When applications provide a discretionary access control mechanism, the
  application must be able to limit the propagation of those access rights.

      The DBMS must ensure the recipient of permissions possesses only the access
  intended. The database must enforce the ability to limit rights propagation if
  that is the intent of the grantor. If the propagation of access rights is not
  limited, users with rights to objects they do not own can continue to grant
  rights to those objects to other users without limit.

      This is default behavior for Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000085-DB-000038'
  tag "gid": 'V-61617'
  tag "rid": 'SV-76107r1_rule'
  tag "stig_id": 'O121-C2-006600'
  tag "fix_id": 'F-67533r1_fix'
  tag "cci": ['CCI-002165']
  tag "nist": ['AC-3 (4)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "Verify the DBMS has the ability to grant permissions without
  the grantee receiving the right to grant those same permissions to another user.

  Review organization policies regarding access propagation. If an access
  propagation policy limiting the propagation of rights does not exist, this is a
  finding.

  Review DBMS configuration to verify access propagation policies are enforced by
  the DBMS as configured. If the DBMS does not enforce the access propagation
  policy, this is a finding."
  tag "fix": "Create and document an access propagation policy that limits the
  propagation of rights.

  Configure the DBMS to enforce the access propagation policy.

  When a user is granted access to an object, they have access to the object.
  When a user is granted access to an object with the GRANT option, then they can
  provide permissions to others.  Without the GRANT option, a user cannot grant
  access to an object.  No configuration is required."
  describe 'A manaul review is required to ensure the Databases utilizing Discretionary Access Control (DAC) enforce a
    policy that limits propagation of access rights' do
    skip 'A manaul review is required to ensure the Databases utilizing Discretionary Access Control (DAC) enforce a
    policy that limits propagation of access rights'
  end
end

control 'V-61717' do
  title 'The DBMS must disable user accounts after 35 days of inactivity.'
  desc  "Password complexity, or strength, is a measure of the effectiveness of
  a password in resisting attempts at guessing and brute-force attacks.

      To meet password policy requirements, passwords need to be changed at
  specific policy-based intervals.

      If the information system or application allows the user to consecutively
  reuse their password when that password has exceeded its defined lifetime, the
  end result is a password that is not changed as per policy requirements.

      Unused or expired DBMS accounts provide a means for undetected,
  unauthorized access to the database.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000163-DB-000113'
  tag "gid": 'V-61717'
  tag "rid": 'SV-76207r2_rule'
  tag "stig_id": 'O121-C2-013800'
  tag "fix_id": 'F-67633r3_fix'
  tag "cci": ['CCI-000795']
  tag "nist": ['IA-4 e)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For accounts managed by Oracle, check DBMS settings to determine if accounts
  can be automatically disabled by the system after 35 days of inactivity. Also,
  ask the DBA if an alternative method, such as a stored procedure run daily, to
  disable Oracle-managed accounts inactive for more than 35 days, has been
  deployed.

  If the ability to disable accounts after 35 days of inactivity, by either of
  these means, does not exist, this is a finding.

  - - - - -

  Check to see what profile each user is associated with, if any, with this query:

  select username, profile from dba_users order by 1,2;

  Then check the profile to see what the password_life_time is set to in the
  table dba_profiles; the password_life_time is a value stored in the LIMIT
  column, and identified by the value PASSWORD_LIFE_TIME in the RESOURCE_NAME
  column.

  SQL>select profile, resource_name, resource_type, limit from dba_profiles where
  upper(resource_name) = 'PASSWORD_LIFE_TIME';"
  tag "fix": "For accounts managed by Oracle, determine if it is practical and
  acceptable to require a password change every 35 days or fewer, rather than the
  standard 60 days (as specified in SRG-APP-000174-DB-000080).  If it is, issue
  the statement:

  ALTER PROFILE PPPPPP LIMIT PASSWORD_LIFE_TIME 35;
  (See the Oracle-provided $ORACLE_HOME/rdbms/admin/secconf.sql script for
  examples.)

  If password changes every 35 days or fewer are unacceptable or impractical,
  implement an alternative method, such as a stored procedure run daily, to
  disable accounts inactive for more than 35 days."

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_LIFE_TIME'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_life_time = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password life time for profile: #{profile}" do
      subject { password_life_time }
      it { should cmp <= input('account_inactivity_age') }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61721' do
  title "The DBMS must support organizational requirements to prohibit password
  reuse for the organization-defined number of generations."
  desc  "Password complexity, or strength, is a measure of the effectiveness of
  a password in resisting attempts at guessing and brute-force attacks.

      To meet password policy requirements, passwords need to be changed at
  specific policy-based intervals.

      If the information system or application allows the user to consecutively
  reuse their password when that password has exceeded its defined lifetime, the
  end result is a password that is not changed as per policy requirements.

      Password reuse restrictions protect against bypass of password expiration
  requirements and help protect accounts from password guessing attempts.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP. This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000165-DB-000081'
  tag "gid": 'V-61721'
  tag "rid": 'SV-76211r2_rule'
  tag "stig_id": 'O121-C2-014000'
  tag "fix_id": 'F-67637r2_fix'
  tag "cci": ['CCI-000200']
  tag "nist": ['IA-5 (1) (e)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password reuse rule, if any, that is in effect:
  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME IN ('PASSWORD_REUSE_MAX', 'PASSWORD_REUSE_TIME')
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE, RESOURCE_NAME;
  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the value of the PASSWORD_REUSE_MAX
  effective for each profile.

  If, for any profile, the PASSWORD_REUSE_MAX value does not enforce the
  DoD-defined minimum number of password changes before a password may be
  repeated (five or greater), this is a finding.

  PASSWORD_REUSE_MAX is effective if and only if PASSWORD_REUSE_TIME is
  specified, so if both are UNLIMITED, this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  For each profile, set the
  PASSWORD_REUSE_MAX to enforce the DoD-defined minimum number of password
  changes before a password may be repeated (five or greater).

  PASSWORD_REUSE_MAX is effective if and only if PASSWORD_REUSE_TIME is
  specified, so ensure also that it has a meaningful value.  Since the minimum
  password lifetime is 1 day, the smallest meaningful value is the same as the
  PASSWORD_REUSE_MAX value.

  Using PPPPPP as an example, the statement to do this is:
  ALTER PROFILE PPPPPP LIMIT PASSWORD_REUSE_MAX 5 PASSWORD_REUSE_TIME 5;"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query_password_max_reuse = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_REUSE_MAX'
  }

  query_password_reuse_time = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_REUSE_TIME'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_reuse_max = sql.query(format(query_password_max_reuse, profile: profile)).column('limit')
    password_reuse_time = sql.query(format(query_password_reuse_time, profile: profile)).column('limit')

    describe "The oracle database account password reuse max for profile: #{profile}" do
      subject { password_reuse_max }
      it { should_not cmp 'UNLIMITED' }
    end

    describe "The oracle database account password reuse time for profile: #{profile}" do
      subject { password_reuse_time }
      it { should_not cmp 'UNLIMITED' }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61605' do
  title "The DBMS must limit the number of consecutive failed logon attempts to
  3."
  desc "Anytime an authentication method is exposed,  to allow for the
  utilization of an application, there is a risk that attempts will be made to
  obtain unauthorized access.

      To defeat these attempts, organizations define the number of times a user
  account may consecutively fail a logon attempt. The organization also defines
  the period of time in which these consecutive failed attempts may occur.

      By limiting the number of failed logon attempts, the risk of unauthorized
  system access via user password guessing, otherwise known as brute forcing, is
  reduced. Limits are imposed by locking the account.

      More recent brute force attacks make attempts over long periods of time to
  circumvent intrusion detection systems and system account lockouts based
  entirely on the number of failed logons that are typically reset after a
  successful logon.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP.  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.

      Note also that a policy that places no limit on the length of the timeframe
  (for counting consecutive invalid attempts) does satisfy this requirement.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000065-DB-000025'
  tag "gid": 'V-61605'
  tag "rid": 'SV-76095r2_rule'
  tag "stig_id": 'O121-C2-005000'
  tag "fix_id": 'F-67521r3_fix'
  tag "cci": ['CCI-000044']
  tag "nist": ['AC-7 a', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "(This addresses both O121-C2-005000 and O121-C2-005200.)

  The limit on the number of consecutive failed logon attempts is defined in the
  profile assigned to a user.

  To see what profile is assigned to a user, enter the following query:
  SQL>SELECT profile FROM dba_users WHERE username = '&USERNAME'
  This will return the profile name assigned to that user.

  Now check the values assigned to the profile returned from the query above:
  SQL>SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE LIKE
  '&PROFILE_NAME'

  Check the settings for FAILED_LOGIN_ATTEMPTS - this is the number of
  consecutive failed logon attempts before locking the Oracle user account. If
  the value is greater than 3, this is a finding."
  tag "fix": "(This addresses both O121-C2-005000 and O121-C2-005200.)

  Configure the DBMS settings to specify the maximum number of consecutive failed
  logon attempts to 3 (or less):
  ALTER PROFILE ORA_STIG_PROFILE LIMIT FAILED_LOGIN_ATTEMPTS 3;

  (ORA_STIG_PROFILE is available in DBA_PROFILES, starting with Oracle 12.1.0.2.
  Note: It remains necessary to create a customized replacement for the password
  validation function, ORA12C_STRONG_VERIFY_FUNCTION, if relying on this
  technique to verify password complexity.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'FAILED_LOGIN_ATTEMPTS'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_lock_time = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database limit for failed login attempts for profile: #{profile}" do
      subject { password_lock_time.first }
      it { should cmp <= input('failed_logon_attempts') }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61719' do
  title "The DBMS must support organizational requirements to enforce minimum
  password length."
  desc "Password complexity, or strength, is a measure of the effectiveness of
  a password in resisting attempts at guessing and brute-force attacks.

      To meet password policy requirements, passwords need to be changed at
  specific policy-based intervals.

      If the information system or application allows the user to consecutively
  reuse their password when that password has exceeded its defined lifetime, the
  end result is a password that is not changed as per policy requirements.

      Weak passwords are a primary target for attack to gain unauthorized access
  to databases and other systems. Where username/password is used for
  identification and authentication to the database, requiring the use of strong
  passwords can help prevent simple and more sophisticated methods for guessing
  at passwords.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP. This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000164-DB-000082'
  tag "gid": 'V-61719'
  tag "rid": 'SV-76209r1_rule'
  tag "stig_id": 'O121-C2-013900'
  tag "fix_id": 'F-67635r1_fix'
  tag "cci": ['CCI-000205']
  tag "nist": ['IA-5 (1) (a)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE;

  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.

  If it does not enforce the DoD-defined minimum length (15 unless otherwise
  specified), this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  Develop, test and implement a
  password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file
  <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the starting point
  for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61723' do
  title "The DBMS must support organizational requirements to enforce password
  complexity by the number of upper-case characters used."
  desc "Password complexity or strength is a measure of the effectiveness of a
  password in resisting attempts at guessing and brute-force attacks.

      Password complexity is one factor of several that determine how long it
  takes to crack a password. The more complex the password is, the greater the
  number of possible combinations that need to be tested before the password is
  compromised.

      Use of a complex password helps to increase the time and resources required
  to compromise the password.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000166-DB-000070'
  tag "gid": 'V-61723'
  tag "rid": 'SV-76213r1_rule'
  tag "stig_id": 'O121-C2-014100'
  tag "fix_id": 'F-67639r1_fix'
  tag "cci": ['CCI-000192']
  tag "nist": ['IA-5 (1) (a)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE;
  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.  If it does
  not enforce the organization-defined minimum number of upper-case characters (1
  unless otherwise specified), this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  Develop, test and implement a
  password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file
  <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the starting point
  for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61725' do
  title "The DBMS must support organizational requirements to enforce password
  complexity by the number of lower-case characters used."
  desc "Password complexity or strength is a measure of the effectiveness of a
  password in resisting attempts at guessing and brute-force attacks.

      Password complexity is one factor of several that determine how long it
  takes to crack a password. The more complex the password is, the greater the
  number of possible combinations that need to be tested before the password is
  compromised.

      Use of a complex password helps to increase the time and resources required
  to compromise the password.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP. This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000167-DB-000071'
  tag "gid": 'V-61725'
  tag "rid": 'SV-76215r1_rule'
  tag "stig_id": 'O121-C2-014200'
  tag "fix_id": 'F-67641r1_fix'
  tag "cci": ['CCI-000193']
  tag "nist": ['IA-5 (1) (a)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE;

  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.

  If it does not enforce the organization-defined minimum number of lower-case
  characters (1 unless otherwise specified), this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  Develop, test and implement a
  password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file
  <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the starting point
  for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61727' do
  title "The DBMS must support organizational requirements to enforce password
  complexity by the number of numeric characters used."
  desc "Password complexity or strength is a measure of the effectiveness of a
  password in resisting attempts at guessing and brute-force attacks.

      Password complexity is one factor of several that determine how long it
  takes to crack a password. The more complex the password is, the greater the
  number of possible combinations that need to be tested before the password is
  compromised.

      Use of a complex password helps to increase the time and resources required
  to compromise the password.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000168-DB-000072'
  tag "gid": 'V-61727'
  tag "rid": 'SV-76217r1_rule'
  tag "stig_id": 'O121-C2-014300'
  tag "fix_id": 'F-67643r1_fix'
  tag "cci": ['CCI-000194']
  tag "nist": ['IA-5 (1) (a)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE;
  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.

  If it does not enforce the organization-defined minimum number of numeric
  characters (1 unless otherwise specified), this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  Develop, test and implement a
  password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file
  <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the starting point
  for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61729' do
  title "The DBMS must support organizational requirements to enforce password
  complexity by the number of special characters used."
  desc "Password complexity or strength is a measure of the effectiveness of a
  password in resisting attempts at guessing and brute-force attacks.

      Password complexity is one factor of several that determine how long it
  takes to crack a password. The more complex the password is, the greater the
  number of possible combinations that need to be tested before the password is
  compromised.

      Use of a complex password helps to increase the time and resources required
  to compromise the password.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000169-DB-000176'
  tag "gid": 'V-61729'
  tag "rid": 'SV-76219r1_rule'
  tag "stig_id": 'O121-C2-014400'
  tag "fix_id": 'F-67645r1_fix'
  tag "cci": ['CCI-001619']
  tag "nist": ['IA-5 (1) (a)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)]
  ORDER BY PROFILE;
  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.

  If it does not enforce the organization-defined minimum number of special
  characters (1 unless otherwise specified), this is a finding."
  tag "fix": "If all user accounts are authenticated by the OS or an
  enterprise-level authentication/access mechanism, and not by Oracle, no fix to
  the DBMS is required.

  If any user accounts are managed by Oracle:  Develop, test and implement a
  password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file
  <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the starting point
  for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61731' do
  title "The DBMS must support organizational requirements to enforce the
  number of characters that get changed when passwords are changed."
  desc  "Passwords need to be changed at specific policy-based intervals.

    If the information system or application allows the user to consecutively
  reuse extensive portions of their password when they change their password, the
  end result is a password that has not had enough elements changed to meet the
  policy requirements.

      Changing passwords frequently can thwart password-guessing attempts or
  re-establish protection of a compromised DBMS account. Minor changes to
  passwords may not accomplish this since password guessing may be able to
  continue to build on previous guesses, or the new password may be easily
  guessed using the old password.

      Note that user authentication and account management must be done via an
  enterprise-wide mechanism whenever possible.  Examples of enterprise-level
  authentication/access mechanisms include, but are not limited to, Active
  Directory and LDAP  This requirement applies to cases where it is necessary to
  have accounts directly managed by Oracle.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000170-DB-000073'
  tag "gid": 'V-61731'
  tag "rid": 'SV-76221r1_rule'
  tag "stig_id": 'O121-C2-014500'
  tag "fix_id": 'F-67647r1_fix'
  tag "cci": ['CCI-000195']
  tag "nist": ['IA-5 (1) (b)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "If all user accounts are managed and authenticated by the OS or
  an enterprise-level authentication/access mechanism, and not by Oracle, this is
  not a finding.

  For each profile that can be applied to accounts where authentication is under
  Oracle's control, determine the password verification function, if any, that is
  in use:

  SELECT * FROM SYS.DBA_PROFILES
  WHERE RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  [AND PROFILE NOT IN (<list of non-applicable profiles>)] ORDER BY PROFILE;

  Bearing in mind that a profile can inherit from another profile, and the root
  profile is called DEFAULT, determine the name of the password verification
  function effective for each profile.

  If, for any profile, the function name is null, this is a finding.

  For each password verification function, examine its source code.

  If it does not enforce the organization-defined minimum number of characters by
  which the password must differ from the previous password (eight of the
  characters unless otherwise specified), this is a finding."
  tag "fix": "If any user accounts are managed by Oracle:  Develop, test and
  implement a password verification function that enforces DoD requirements.

  (Oracle supplies a sample function called ORA12C_STRONG_VERIFY_FUNCTION, in the
  script file <oracle_home>/RDBMS/ADMIN/utlpwdmg.sql.  This can be used as the
  starting point for a customized function.)"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'PASSWORD_VERIFY_FUNCTION'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    password_verify_function = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database account password verify function for profile: #{profile}" do
      subject { password_verify_function }
      it { should_not eq ['NULL'] }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61757' do
  title "The DBMS must terminate the network connection associated with a
  communications session at the end of the session or 15 minutes of inactivity."
  desc "Non-local maintenance and diagnostic activities are those activities
  conducted by individuals communicating through a network, either an external
  network (e.g., the Internet) or an internal network.

      The act of managing systems and applications includes the ability to access
  sensitive application information, such as system configuration details,
  diagnostic information, user information, and potentially sensitive application
  data.

      When applications provide a remote management capability inherent to the
  application, the application needs to ensure all sessions and network
  connections are terminated when non-local maintenance is completed.

      When network connections are left open after the database session has
  closed, the network session is open to session hijacking.

      The Oracle Listener inherently meets most of this SRG requirement.  When a
  user logs off, or times out, or encounters an unrecoverable network fault, the
  Oracle Listener terminates all sessions and network connections.  The remaining
  aspect of the requirement, the timeout because of inactivity, is configurable.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000190-DB-000137'
  tag "gid": 'V-61757'
  tag "rid": 'SV-76247r2_rule'
  tag "stig_id": 'O121-C2-016500'
  tag "fix_id": 'F-67673r2_fix'
  tag "cci": ['CCI-001133']
  tag "nist": ['SC-10', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "Review DBMS settings, OS settings, and vendor documentation to
  verify network connections are terminated when a database communications
  session is ended or after 15 minutes of inactivity.

  If the network connection is not terminated, this is a finding.

  The defined duration for these timeouts 15 minutes, except to fulfill
  documented and validated mission requirements."
  tag "fix": "Configure DBMS and/or OS settings to disconnect network sessions
  when database communication sessions have ended or after the DoD-defined period
  of inactivity.

  To configure this in Oracle, modify each relevant profile.  The resource name
  is IDLE_TIME, which is expressed in minutes.  Using PPPPPP as an example of a
  profile, set the timeout to 15 minutes with:
  ALTER PROFILE PPPPPP LIMIT IDLE_TIME 15;"

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  query = %{
    SELECT PROFILE, RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE PROFILE =
  '%<profile>s' AND RESOURCE_NAME = 'IDLE_TIME'
  }

  user_profiles = sql.query('SELECT profile FROM dba_users;').column('profile').uniq

  user_profiles.each do |profile|
    next if profile == "RDSADMIN"
    idle_time = sql.query(format(query, profile: profile)).column('limit')

    describe "The oracle database idele time for profile: #{profile}" do
      subject { idle_time }
      it { should cmp <= 15 }
    end
  end
  if user_profiles.empty?
    describe 'There are no user profiles, therefore this control is NA' do
      skip 'There are no user profiles, therefore this control is NA'
    end
  end
end

control 'V-61541' do
  title 'DBMS default accounts must be assigned custom passwords.'
  desc  "Password maximum lifetime is  the maximum period of time, (typically
in days) a user's password may be in effect before the user is forced to change
it.
    Passwords need to be changed at specific policy-based intervals as per
policy. Any password, no matter how complex, can eventually be cracked.
    One method of minimizing this risk is to use complex passwords and
periodically change them. If the application does not limit the lifetime of
passwords and force users to change their passwords, there is the risk that the
system and/or application passwords could be compromised.
    DBMS default passwords provide a commonly known and exploited means for
unauthorized access to database installations.
  "
  impact 0.7
  tag "gtitle": 'SRG-APP-000174-DB-000078'
  tag "gid": 'V-61541'
  tag "rid": 'SV-76031r1_rule'
  tag "stig_id": 'O121-C1-015000'
  tag "fix_id": 'F-67457r1_fix'
  tag "cci": ['CCI-000199']
  tag "nist": ['IA-5 (1) (d)', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "Use this query to identify the Oracle-supplied accounts that
  still have their default passwords:
  SELECT * FROM SYS.DBA_USERS_WITH_DEFPWD;
  If any accounts other than XS$NULL are listed, this is a finding.
  (XS$NULL is an internal account that represents the absence of a user in a
  session. Because XS$NULL is not a user, this account can only be accessed by
  the Oracle Database instance. XS$NULL has no privileges and no one can
  authenticate as XS$NULL, nor can authentication credentials ever be assigned to
  XS$NULL.)"
  tag "fix": "Change passwords for DBMS accounts to non-default values. Where
  necessary, unlock or enable accounts to change the password, and then return
  the account to disabled or locked status."

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  sys_dba_users_with_defpwd = sql.query(' SELECT username FROM SYS.DBA_USERS_WITH_DEFPWD;').column('username').uniq

  describe.one do
    sys_dba_users_with_defpwd.each do |user|
      next if user == "RDSADMIN"
      describe "The oracle system database user: #{user} with a default password" do
        subject { user }
        it { should cmp 'XS$NULL' }
      end
    end

    describe sys_dba_users_with_defpwd do
      it { should be_empty }
    end
  end
end

control 'V-61421' do
  title "The Oracle WITH GRANT OPTION privilege must not be granted to non-DBA
  or non-Application administrator user accounts."
  desc "An account permission to grant privileges within the database is an
  administrative function. Minimizing the number and privileges of administrative
  accounts reduces the chances of privileged account exploitation. Application
  user accounts must never require WITH GRANT OPTION privileges since, by
  definition, they require only privileges to execute procedures or view / edit
  data."
  impact 0.5
  tag "gtitle": 'SRG-APP-000516-DB-999900'
  tag "gid": 'V-61421'
  tag "rid": 'SV-75911r2_rule'
  tag "stig_id": 'O121-BP-021700'
  tag "fix_id": 'F-67337r1_fix'
  tag "cci": ['CCI-000366']
  tag "nist": ['CM-6 b', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "Execute the query:
  select grantee||': '||owner||'.'||table_name
  from dba_tab_privs
  where grantable = 'YES'
  and grantee not in (select distinct owner from dba_objects)
  and grantee not in (select grantee from dba_role_privs where granted_role =
  'DBA')
  order by grantee;
  If any accounts are listed, this is a finding."
  tag "fix": "Revoke privileges granted the WITH GRANT OPTION from non-DBA and
  accounts that do not own application objects.
  Re-grant privileges without specifying WITH GRANT OPTION."

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  describe sql.query("select grantee||': '||owner||'.'||table_name
  from dba_tab_privs
  where grantable = 'YES'
  and grantee not in (select distinct owner from dba_objects)
  and grantee not in (select grantee from dba_role_privs where granted_role =
  'DBA')
  and owner not in ('RDSADMIN')
  order by grantee;").row(0).column("grantee||': '||owner||'.'||table_name") do
    its('value') { should be_empty }
  end
end


control 'V-61591' do
  title "Administrative privileges must be assigned to database accounts via
  database roles."
  desc "Applications employ the concept of least privilege for specific duties
  and information systems (including specific functions, ports, protocols, and
  services). The concept of least privilege is also applied to information system
  processes, ensuring that the processes operate at privilege levels no higher
  than necessary to accomplish required organizational missions and/or functions.
  Organizations consider the creation of additional processes, roles, and
  information system accounts as necessary to achieve least privilege.
  Organizations also apply least privilege concepts to the design, development,
  implementation, and operations of information systems.
      Privileges granted outside the context of the application user job function
  are more likely to go unmanaged or without oversight for authorization.
  Maintenance of privileges using roles defined for discrete job functions offers
  improved oversight of application user privilege assignments and helps to
  protect against unauthorized privilege assignment.
  "
  impact 0.5
  tag "gtitle": 'SRG-APP-000062-DB-000034'
  tag "gid": 'V-61591'
  tag "rid": 'SV-76081r3_rule'
  tag "stig_id": 'O121-C2-004000'
  tag "fix_id": 'F-67507r1_fix'
  tag "cci": ['CCI-000366', 'CCI-002220']
  tag "nist": ['CM-6 b', 'Rev_4']
  tag "nist": ['AC-5 c', 'Rev_4']
  tag "false_negatives": nil
  tag "false_positives": nil
  tag "documentable": false
  tag "mitigations": nil
  tag "severity_override_guidance": false
  tag "potential_impacts": nil
  tag "third_party_tools": nil
  tag "mitigation_controls": nil
  tag "responsibility": nil
  tag "ia_controls": nil
  tag "check": "Review accounts for direct assignment of administrative
  privileges.  Connected as SYSDBA, run the query:
  SELECT grantee, privilege
  FROM   dba_sys_privs
  WHERE  grantee IN
  (
  SELECT username
  FROM   dba_users
  WHERE  username NOT IN
  (
  'XDB', 'SYSTEM', 'SYS', 'LBACSYS',
  'DVSYS', 'DVF', 'SYSMAN_RO',
  'SYSMAN_BIPLATFORM', 'SYSMAN_MDS',
  'SYSMAN_OPSS', 'SYSMAN_STB', 'DBSNMP',
  'SYSMAN', 'APEX_040200', 'WMSYS',
  'SYSDG', 'SYSBACKUP', 'SPATIAL_WFS_ADMIN_USR',
  'SPATIAL_CSW_ADMIN_US', 'GSMCATUSER',
  'OLAPSYS', 'SI_INFORMTN_SCHEMA',
  'OUTLN', 'ORDSYS', 'ORDDATA', 'OJVMSYS',
  'ORACLE_OCM', 'MDSYS', 'ORDPLUGINS',
  'GSMADMIN_INTERNAL', 'MDDATA', 'FLOWS_FILES',
  'DIP', 'CTXSYS', 'AUDSYS',
  'APPQOSSYS', 'APEX_PUBLIC_USER', 'ANONYMOUS',
  'SPATIAL_CSW_ADMIN_USR', 'SYSKM',
  'SYSMAN_TYPES', 'MGMT_VIEW',
  'EUS_ENGINE_USER', 'EXFSYS', 'SYSMAN_APM'
  )
  )
  AND privilege NOT IN ('UNLIMITED TABLESPACE'
                   , 'REFERENCES', 'INDEX', 'SYSDBA', 'SYSOPER'
  )
  ORDER  BY 1, 2;
  If any administrative privileges have been assigned directly to a database
  account, this is a finding.
  (The list of special accounts that are excluded from this requirement may not
  be complete.  It is expected that the DBA will edit the list to suit local
  circumstances, adding other special accounts as necessary, and removing any
  that are not supposed to be in use in the Oracle deployment that is under
  review.)"
  tag "fix": "Create roles for administrative function assignments. Assign the
  necessary privileges for the administrative functions to a role.  Do not assign
  administrative privileges directly to users, except for those that Oracle does
  not permit to be assigned via roles."

  sql = oracledb_session(user: input('user'), password: input('password'), host: input('host'), service: input('service'), sqlplus_bin: input('sqlplus_bin'))

  database_accounts_with_administrative_privs = sql.query("SELECT grantee
  FROM   dba_sys_privs
  WHERE  grantee IN
  (
  SELECT username
  FROM   dba_users
  WHERE  username NOT IN
  (
  'XDB', 'SYSTEM', 'SYS', 'LBACSYS',
  'DVSYS', 'DVF', 'SYSMAN_RO',
  'SYSMAN_BIPLATFORM', 'SYSMAN_MDS',
  'SYSMAN_OPSS', 'SYSMAN_STB', 'DBSNMP',
  'SYSMAN', 'APEX_040200', 'WMSYS',
  'SYSDG', 'SYSBACKUP', 'SPATIAL_WFS_ADMIN_USR',
  'SPATIAL_CSW_ADMIN_US', 'GSMCATUSER',
  'OLAPSYS', 'SI_INFORMTN_SCHEMA',
  'OUTLN', 'ORDSYS', 'ORDDATA', 'OJVMSYS',
  'ORACLE_OCM', 'MDSYS', 'ORDPLUGINS',
  'GSMADMIN_INTERNAL', 'MDDATA', 'FLOWS_FILES',
  'DIP', 'CTXSYS', 'AUDSYS',
  'APPQOSSYS', 'APEX_PUBLIC_USER', 'ANONYMOUS',
  'SPATIAL_CSW_ADMIN_USR', 'SYSKM',
  'SYSMAN_TYPES', 'MGMT_VIEW',
  'EUS_ENGINE_USER', 'EXFSYS', 'SYSMAN_APM', 'RDSADMIN'
  )
  )
  AND privilege NOT IN ('UNLIMITED TABLESPACE'
                   , 'REFERENCES', 'INDEX', 'SYSDBA', 'SYSOPER'
  );").column('grantee').uniq

  describe 'Database accounts with administrative privileges' do
    subject { database_accounts_with_administrative_privs }
    it { should be_empty }
  end
end

end
